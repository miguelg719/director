// import { v4 as uuidv4 } from 'uuid';
import { Subtask, TaskPlan } from './planner';
import { WorkerResult } from './worker';
import { Stagehand } from "@browserbasehq/stagehand";

// Simple function to generate a random ID
function generateId(length = 16): string {
  return Math.random().toString(36).substring(2, length + 2) + Date.now().toString(36);
}

// Task status
type TaskStatus = 'PENDING' | 'IN_PROGRESS' | 'DONE' | 'FAILED';

// Task interface
export interface Task {
  id: string;
  goal: string;
  status: TaskStatus;
  plan: TaskPlan;
  sessionId: string;
  createdAt: Date;
  updatedAt: Date;
  results: {
    [subtaskId: string]: WorkerResult | null;
  };
}

// Progress interface
export interface TaskProgress {
  total: number;
  completed: number;
  failed: number;
  inProgress: number;
  pending: number;
}

// In-memory store for tasks (would use a database in production)
const taskStore: Map<string, Task> = new Map();

/**
 * Create a new task with a plan
 * 
 * @param goal The user's goal
 * @param plan The task plan generated by the planner
 * @param sessionId The browser session ID
 * @returns The created task
 */
export function createTask(goal: string, plan: TaskPlan, sessionId: string): Task {
  const taskId = generateId();
  
  const task: Task = {
    id: taskId,
    goal,
    status: 'PENDING',
    plan,
    sessionId,
    createdAt: new Date(),
    updatedAt: new Date(),
    results: {}
  };
  
  // Initialize results for each subtask
  for (const subtask of plan.subtasks) {
    task.results[subtask.id] = null;
  }
  
  taskStore.set(taskId, task);
  return task;
}

/**
 * Get a task by ID
 * 
 * @param taskId The task ID
 * @returns The task or null if not found
 */
export function getTask(taskId: string): Task | null {
  return taskStore.get(taskId) || null;
}

/**
 * Get the next available subtask for a worker to execute
 * 
 * @param taskId The task ID
 * @returns The next available subtask or null if none available
 */
export function getNextAvailableSubtask(taskId: string): Subtask | null {
  const task = taskStore.get(taskId);
  if (!task) return null;
  
  // Mark task as in progress if it's pending
  if (task.status === 'PENDING') {
    task.status = 'IN_PROGRESS';
    task.updatedAt = new Date();
  }
  
  // Find a pending subtask that has all dependencies completed
  for (const subtask of task.plan.subtasks) {
    if (subtask.status !== 'PENDING') continue;
    
    // Check if all dependencies are completed
    const allDependenciesDone = !subtask.dependencies || 
      subtask.dependencies.every(depId => {
        const depSubtask = task.plan.subtasks.find(st => st.id === depId);
        return depSubtask && depSubtask.status === 'DONE';
      });
    
    if (allDependenciesDone) {
      // Mark subtask as in progress
      subtask.status = 'IN_PROGRESS';
      task.updatedAt = new Date();
      return subtask;
    }
  }
  
  return null;
}

/**
 * Update the status of a subtask
 * 
 * @param taskId The task ID
 * @param subtaskId The subtask ID
 * @param status The new status
 * @param result The worker result
 * @returns True if successful, false otherwise
 */
export function updateSubtaskStatus(
  taskId: string, 
  subtaskId: string, 
  status: 'DONE' | 'FAILED',
  result: WorkerResult
): boolean {
  const task = taskStore.get(taskId);
  if (!task) return false;
  
  // Find the subtask in the task's plan
  const subtaskIndex = task.plan.subtasks.findIndex(st => st.id === subtaskId);
  if (subtaskIndex === -1) return false;
  
  // Update the subtask status
  task.plan.subtasks[subtaskIndex].status = status;
  
  // Add the result to the task results
  task.results[subtaskId] = result;
  
  // Update the overall task status
  updateTaskStatus(task);
  
  // Update the task's updatedAt timestamp
  task.updatedAt = new Date();
  
  return true;
}

/**
 * Update task status based on subtask statuses
 * 
 * @param task The task to update
 */
function updateTaskStatus(task: Task): void {
  const { total, completed, failed, pending, inProgress } = getTaskProgress(task);
  
  if (total === 0) {
    // No subtasks - should never happen
    return;
  }
  
  // If any subtasks are still in progress or pending, the task is still in progress
  if (inProgress > 0 || pending > 0) {
    task.status = 'IN_PROGRESS';
    return;
  }
  
  // If all subtasks are either DONE or FAILED
  if (completed + failed === total) {
    // If any subtasks failed, mark the task as failed
    if (failed > 0) {
      task.status = 'FAILED';
    } else {
      task.status = 'DONE';
      
      // If the task is done, we can safely close the session
      closeSessionIfTaskComplete(task);
    }
  }
}

/**
 * Closes the browser session when the task is complete
 * 
 * @param task The completed task
 */
async function closeSessionIfTaskComplete(task: Task): Promise<void> {
  if (task.status !== 'DONE') return;
  
  try {
    console.log(`[TASK_MANAGER] Closing session for completed task: ${task.id}`);
    
    // Use stagehand to close the session
    const stagehand = new Stagehand({
      browserbaseSessionID: task.sessionId,
      env: "BROWSERBASE",
      logger: () => {},
    });
    
    await stagehand.init();
    await stagehand.close();
    
    console.log(`[TASK_MANAGER] Session closed successfully for task: ${task.id}`);
  } catch (error) {
    console.error(`[TASK_MANAGER] Error closing session for task ${task.id}:`, error);
  }
}

/**
 * Get the progress of a task
 * 
 * @param taskId The task ID
 * @returns The task progress
 */
export function getTaskProgressById(taskId: string): TaskProgress | null {
  const task = taskStore.get(taskId);
  if (!task) return null;
  
  return getTaskProgress(task);
}

/**
 * Get the progress of a task
 * 
 * @param task The task
 * @returns The task progress
 */
function getTaskProgress(task: Task): TaskProgress {
  const subtasks = task.plan.subtasks;
  
  const progress: TaskProgress = {
    total: subtasks.length,
    completed: 0,
    failed: 0,
    inProgress: 0,
    pending: 0
  };
  
  for (const subtask of subtasks) {
    switch (subtask.status) {
      case 'DONE':
        progress.completed++;
        break;
      case 'FAILED':
        progress.failed++;
        break;
      case 'IN_PROGRESS':
        progress.inProgress++;
        break;
      case 'PENDING':
        progress.pending++;
        break;
    }
  }
  
  return progress;
}

/**
 * Get all subtasks for a task
 * 
 * @param taskId The task ID
 * @returns The subtasks or null if task not found
 */
export function getSubtasks(taskId: string): Subtask[] | null {
  const task = taskStore.get(taskId);
  if (!task) return null;
  
  return task.plan.subtasks;
}

/**
 * Get all results for a task
 * 
 * @param taskId The task ID
 * @returns The results or null if task not found
 */
export function getResults(taskId: string): { [subtaskId: string]: WorkerResult | null } | null {
  const task = taskStore.get(taskId);
  if (!task) return null;
  
  return task.results;
}

/**
 * Get the overall result of a task
 * 
 * @param taskId The task ID
 * @returns The overall result or null if task not found or not completed
 */
export function getOverallResult(taskId: string): any | null {
  const task = taskStore.get(taskId);
  if (!task || task.status !== 'DONE') return null;
  
  // Combine results from all subtasks
  const combinedResult: any = {
    taskId: task.id,
    goal: task.goal,
    summary: task.plan.summary,
    subtasks: task.plan.subtasks.map(st => ({
      id: st.id,
      description: st.description,
      goal: st.goal,
      status: st.status,
      steps: task.results[st.id]?.steps || []
    }))
  };
  
  return combinedResult;
} 